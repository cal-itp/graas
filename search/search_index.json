{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"================================== GRaaS is a software program which creates GTFS-RT data using a variety of Android, iOS, and other internet capable devices. This lets you - and transit riders - know where your vehicle is in real time and plan your trip accordingly! Background & Overview The California Integrated Travel Project (Cal-ITP) launched in 2019 with specific goals to improve public transport across the state and beyond. One of the main goals of the project was to provide accurate and complete information for trip planning in real time in a way that gave transit agencies ownership over their own data: an end to black boxes. Cal-ITP looked to create an open-source software which created open data in an open standard. Thus, GRaaS was born. GRaaS adds to the growing number of Mobility \u2018as a Service\u2019 projects in the transit sphere. The software creates real-time data in the General Transit Feed Standard (GTFS) format: vehicle positions and service alerts. (Note: At this time, we are not providing trip updates). We\u2019re working to make transit data open and accessible for all. As the industry standard, GTFS-rt feeds can be read by most journey planning apps like Google Maps, Apple Maps, TransitApp, etc. Before GRaaS, transit agencies could either pay specialized companies or simply not provide real-time information. We created GRaaS to change that. The software runs on variety of Android, iOS, and other internet capable devices and generates a set of URLs that journey planning apps accept. It\u2019s easy for agencies and easy for riders, who see the up-to-date info right on their smartphones. Components: Flask/Python server deployed to Google App engine A library of Java tools A web app for transit vehicles to post updates On-board internet capable device Pre-requisites A dedicated internet-capable smartphone tablets on each transit vehicle The technical ability to deploy a GCP flask app Setup & deployment To set up and begin running your own instance of GRaaS, follow the GRaaS setup instructions . To see if you have everything set up correctly. Try deploying the web app, as outlined in the server README . See the Agency Onboarding Runbook for instructions on adding a specific agency to your GRaaS instance. For instructions on how to get a transit agency set up with the GRaaS mobile app, see the Agency Onboarding Instructions . Recommended Hardware: The team has also developed a hardware version of GRaaS that is completely dedicated to transmitting GTFS data. This was developed as a solution to various issues that we found during our demonstrations using different tablets and smartphones such as screen timeouts, OS updates, and more. You can still use GRaaS on other hardware such as tablets and smartphones. However, the following operational guidelines should be followed: Use an internet enabled device, not a WIFI only device Ensure that the device is connected to data, either via a SIM card or WIFI connection Do not lock the device as it disrupts location data Check that all software is up-to-date before running the app to eliminate any pop-ups which disrupt location services The team has tested the following tablets and phones in the field and are confident in their ability to run the software: iPad Samsung Galaxy Tab Support Transit Agency or Operator in California: If you would like to use this software as a part of the on-going California Integrated Travel Project (Cal-ITP), please contact support@calitp.org . Our team is available to help as a complementary service offered through Caltrans. If this message is displayed, the opportunity is still available for CA transit agencies and operators. Transit Agency or Operator outside CA: If you tried the software and would like to learn more about how Caltrans and the California Integrated Travel Project (Cal-ITP) are supporting open-source data solutions, please contact hello@calitp.org . If you would like to see a similar partnership in your state, encourage your state DOT to engage with Cal-ITP staff. If you would like to ask a question, create an issue labeled as a question in github. If you would like to report an issue, submit a bug-report issue in github. Development Roadmap Here are some areas that we working on: Removing driver interaction Automating trip reports Adding full trip updates feature (i.e., arrival predictions in-house, rather than through journey planning app) Setting up alerts feature with ADA integrations If you would like to make an edit or request a new feature, send a pull request / submit an issue in github. Alternatively, you can email support@calitp.org . Contributing We are still working on contribution guidelines as this is a new project. We expect to accept suggestions and edits, which adhere to a code of conduct, but are still refining the process.","title":"Introduction"},{"location":"#background-overview","text":"The California Integrated Travel Project (Cal-ITP) launched in 2019 with specific goals to improve public transport across the state and beyond. One of the main goals of the project was to provide accurate and complete information for trip planning in real time in a way that gave transit agencies ownership over their own data: an end to black boxes. Cal-ITP looked to create an open-source software which created open data in an open standard. Thus, GRaaS was born. GRaaS adds to the growing number of Mobility \u2018as a Service\u2019 projects in the transit sphere. The software creates real-time data in the General Transit Feed Standard (GTFS) format: vehicle positions and service alerts. (Note: At this time, we are not providing trip updates). We\u2019re working to make transit data open and accessible for all. As the industry standard, GTFS-rt feeds can be read by most journey planning apps like Google Maps, Apple Maps, TransitApp, etc. Before GRaaS, transit agencies could either pay specialized companies or simply not provide real-time information. We created GRaaS to change that. The software runs on variety of Android, iOS, and other internet capable devices and generates a set of URLs that journey planning apps accept. It\u2019s easy for agencies and easy for riders, who see the up-to-date info right on their smartphones. Components: Flask/Python server deployed to Google App engine A library of Java tools A web app for transit vehicles to post updates On-board internet capable device Pre-requisites A dedicated internet-capable smartphone tablets on each transit vehicle The technical ability to deploy a GCP flask app","title":"Background &amp; Overview"},{"location":"#setup-deployment","text":"To set up and begin running your own instance of GRaaS, follow the GRaaS setup instructions . To see if you have everything set up correctly. Try deploying the web app, as outlined in the server README . See the Agency Onboarding Runbook for instructions on adding a specific agency to your GRaaS instance. For instructions on how to get a transit agency set up with the GRaaS mobile app, see the Agency Onboarding Instructions . Recommended Hardware: The team has also developed a hardware version of GRaaS that is completely dedicated to transmitting GTFS data. This was developed as a solution to various issues that we found during our demonstrations using different tablets and smartphones such as screen timeouts, OS updates, and more. You can still use GRaaS on other hardware such as tablets and smartphones. However, the following operational guidelines should be followed: Use an internet enabled device, not a WIFI only device Ensure that the device is connected to data, either via a SIM card or WIFI connection Do not lock the device as it disrupts location data Check that all software is up-to-date before running the app to eliminate any pop-ups which disrupt location services The team has tested the following tablets and phones in the field and are confident in their ability to run the software: iPad Samsung Galaxy Tab","title":"Setup &amp; deployment"},{"location":"#support","text":"Transit Agency or Operator in California: If you would like to use this software as a part of the on-going California Integrated Travel Project (Cal-ITP), please contact support@calitp.org . Our team is available to help as a complementary service offered through Caltrans. If this message is displayed, the opportunity is still available for CA transit agencies and operators. Transit Agency or Operator outside CA: If you tried the software and would like to learn more about how Caltrans and the California Integrated Travel Project (Cal-ITP) are supporting open-source data solutions, please contact hello@calitp.org . If you would like to see a similar partnership in your state, encourage your state DOT to engage with Cal-ITP staff. If you would like to ask a question, create an issue labeled as a question in github. If you would like to report an issue, submit a bug-report issue in github.","title":"Support"},{"location":"#development-roadmap","text":"Here are some areas that we working on: Removing driver interaction Automating trip reports Adding full trip updates feature (i.e., arrival predictions in-house, rather than through journey planning app) Setting up alerts feature with ADA integrations If you would like to make an edit or request a new feature, send a pull request / submit an issue in github. Alternatively, you can email support@calitp.org .","title":"Development Roadmap"},{"location":"#contributing","text":"We are still working on contribution guidelines as this is a new project. We expect to accept suggestions and edits, which adhere to a code of conduct, but are still refining the process.","title":"Contributing"},{"location":"attribution/","text":"We've used the following open source libraries to build GRaaS: Flask The BSD-3-Clause license applies to all files in the Flask repository and source distribution. This includes Flask\u2019s source code, the examples, and tests, as well as the documentation. Copyright 2010 Pallets Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Python ECDSA The MIT License (MIT) \"python-ecdsa\" Copyright (c) 2010 Brian Warner Portions written in 2005 by Peter Pearson and placed in the public domain. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. NoSleep.js The MIT License (MIT) Copyright (c) Rich Tibbett Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Six The MIT License (MIT) Copyright (c) 2010-2020 Benjamin Peterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Attribution"},{"location":"attribution/#flask","text":"The BSD-3-Clause license applies to all files in the Flask repository and source distribution. This includes Flask\u2019s source code, the examples, and tests, as well as the documentation. Copyright 2010 Pallets Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Flask"},{"location":"attribution/#python-ecdsa","text":"The MIT License (MIT) \"python-ecdsa\" Copyright (c) 2010 Brian Warner Portions written in 2005 by Peter Pearson and placed in the public domain. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Python ECDSA"},{"location":"attribution/#nosleepjs","text":"The MIT License (MIT) Copyright (c) Rich Tibbett Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"NoSleep.js"},{"location":"attribution/#six","text":"The MIT License (MIT) Copyright (c) 2010-2020 Benjamin Peterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Six"},{"location":"new-instance-setup/","text":"GRaaS Instance Setup Follow these instructions to set up your own instance of GRaaS. Clone or fork the GRaaS repo. From server/app-engine , set up a python virtual environment , and then run pip install -r requirements.txt to install dependencies. Create a new Google Cloud project (you will need to login to a Google user account first). Navigate to \"Cloud Storage\" and, if you haven't already, start a free trial. This is the one part of the setup where you'll need to put down a credit card - Google says you won't be charged without a warning. Follow the quickstart instructions here to install the latest SDK version, and then follow steps 1-4 of under \"Initializing the Cloud SDK\". Follow Google's instructions for Creating a service account and Setting the environment variable here . Grant the service account the role of \"Storage Admin.\" Under IAM & Admin > IAM, grant your Google account email address and the service account with Storage Admin, Storage Object Admin, and Cloud Datastore Owner access. Follow steps 1-3 under Add Firebase to your Project . Enable Hosting. Navigate to the Firebase config object , and update server/static/firebaseconfig.js with the variables from your project. Generate keys for HTTPS authentication, by running the following command: openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365 . This will generate two files, cert.pem and key.pem. You are ready to run the server locally: from your virtual environment, run python main.py -c <path-to-cert.pem> -k <path-to-key.pem> . This should launch the local server - from a web browser, go to the URL listed (likely https://127.0.0.1:8080). If the webpage loads correctly, continue to the next step. Follow instructions in the Onboarding Runbook to create a new test agency. Note that you'll need to replace the directory path 'graas-resources' in server/agency-config/gtfs/copy-to-bucket.sh , server/app-engine/static/graas.js , server/app-engine/util.py . Once you have a new agency created, load the local web app again and scan the QR you've just created (you'll need to pull it up on a separate device, or print it). Deploy the app with gcloud app deploy .","title":"New instance setup"},{"location":"new-instance-setup/#graas-instance-setup","text":"Follow these instructions to set up your own instance of GRaaS. Clone or fork the GRaaS repo. From server/app-engine , set up a python virtual environment , and then run pip install -r requirements.txt to install dependencies. Create a new Google Cloud project (you will need to login to a Google user account first). Navigate to \"Cloud Storage\" and, if you haven't already, start a free trial. This is the one part of the setup where you'll need to put down a credit card - Google says you won't be charged without a warning. Follow the quickstart instructions here to install the latest SDK version, and then follow steps 1-4 of under \"Initializing the Cloud SDK\". Follow Google's instructions for Creating a service account and Setting the environment variable here . Grant the service account the role of \"Storage Admin.\" Under IAM & Admin > IAM, grant your Google account email address and the service account with Storage Admin, Storage Object Admin, and Cloud Datastore Owner access. Follow steps 1-3 under Add Firebase to your Project . Enable Hosting. Navigate to the Firebase config object , and update server/static/firebaseconfig.js with the variables from your project. Generate keys for HTTPS authentication, by running the following command: openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365 . This will generate two files, cert.pem and key.pem. You are ready to run the server locally: from your virtual environment, run python main.py -c <path-to-cert.pem> -k <path-to-key.pem> . This should launch the local server - from a web browser, go to the URL listed (likely https://127.0.0.1:8080). If the webpage loads correctly, continue to the next step. Follow instructions in the Onboarding Runbook to create a new test agency. Note that you'll need to replace the directory path 'graas-resources' in server/agency-config/gtfs/copy-to-bucket.sh , server/app-engine/static/graas.js , server/app-engine/util.py . Once you have a new agency created, load the local web app again and scan the QR you've just created (you'll need to pull it up on a separate device, or print it). Deploy the app with gcloud app deploy .","title":"GRaaS Instance Setup"},{"location":"gtfu/","text":"General Transit Feed Utilities This repository provides a number of tools and utilities to monitor GTFS realtime feeds. The tools are detailed in the sections below. The Realtime Visualization component is very suitable for high-level validation of both static GTFS and Vehicle Position feeds for an operator. Finally, there is a utility to post Service Alerts. Vehicle Position Feed A command line utility that continuously displays vehicle position data for an operator to a terminal window. For each vehicle, when available, we display the distance traveled since the last update, the heading (indicated by an arrow), speed and time since last time. Vehicle IDs are shown with a green, yellow or red background, depending on how stale their last update is. To run: scripts/monitor-position-updates.sh -url <vehicle-position-url> With Docker and Docker Compose: docker-compose run positions_feed -url <vehicle-position-url> Service Alert Feed A command line utility that dumps active alerts for an operator to a terminal window. To run: scripts/dump-service-alerts.sh <service-alert-url> With Docker and Docker Compose: docker-compose run service_alerts <service-alert-url> Service Alert UI A desktop app to let a user post GTFS service alerts. To run: scripts/alert-ui.sh -url <path-to-config-file> Below is an example for a config file. Make sure to substitute the appropriate values for your scenario. { \"private_key_file\": \"/Users/foo/id_rsa\", \"static_gtfs_url\": \"http://operator.com/gtfs.zip\", \"post_url\": \"https://operator.com/post-service-alert\" } Realtime Operator Visualization Provides ongoing realtime visualization for a GTFS-rt compliant operator. Visuals are created by combining the static GTFS data with the realtime Vehicle Position Feed. Coordinates are auto-scaled to display all routes for an operator. Routes are drawn in the colors specified in the GTFS file. Stops are drawn in gray, vehicles are shown in magenta. Clicking on a stop shows the stop name, clicking on a vehicle shows the schedule adherence status (early, on time, late). In the upper left corner, we show the operator name, and vehicle, stop and trip count. The first time data for an operator is shown, the system downloads and caches the static GTFS zip file. On subsequent runs, the modification time of the zip URL is checked against the cache timestamp. If the URL content is newer, we update the cache. The vehicle position feed is sampled every few seconds, and any updates are reflected on the screen. Pressing n or p switches to the next or previous operator feed, respectively. We show a loading overlay while switching operators. The overlay has two progress bars, data download up top and data parsing at the bottom. To run: scripts/realtime-visualization.sh <path-to-config-file> Below is an example for a config file. Make sure to substitute the appropriate values for your scenario. [ { \"agency_id\": \"agency-1\", \"static_gtfs_url\": \"http://agency-1.com/gtfs.zip\", \"vehicle_position_url\": \"http://agency-1.com/vehicle-positions.pb\" }, { \"agency_id\": \"agency-2\", \"static_gtfs_url\": \"http://agency-2.com/gtfs.zip\", \"vehicle_position_url\": \"http://agency-2.com/vehicle-positions.pb\" }, ] Trip List Utility A command line utility for generating a list of friendly trip names from a static GTFS feed. This is part of the onboarding process for new operators, see here for more details. To run: scripts/dump-service-alerts.sh <tmp-dir> <agency-id> <static-gtfs-url> With Docker and Docker Compose: docker-compose run trip_list_generator <tmp-dir> <agency-id> <static-gtfs-url> Use something like /tmp/gtfu-cache as tmp-dir . GTFS Validator This library utilizes MobilityData's gtfs-validator tool . It runs as a part of the TripListGenerator tool, and you can also run it with the command: java -cp build/libs/gtfu.jar gtfu.tools.GTFSValidator <agency-static-gtfs-url> To Build gradle distZip","title":"General Transit Feed Utilities"},{"location":"gtfu/#general-transit-feed-utilities","text":"This repository provides a number of tools and utilities to monitor GTFS realtime feeds. The tools are detailed in the sections below. The Realtime Visualization component is very suitable for high-level validation of both static GTFS and Vehicle Position feeds for an operator. Finally, there is a utility to post Service Alerts.","title":"General Transit Feed Utilities"},{"location":"gtfu/#vehicle-position-feed","text":"A command line utility that continuously displays vehicle position data for an operator to a terminal window. For each vehicle, when available, we display the distance traveled since the last update, the heading (indicated by an arrow), speed and time since last time. Vehicle IDs are shown with a green, yellow or red background, depending on how stale their last update is. To run: scripts/monitor-position-updates.sh -url <vehicle-position-url> With Docker and Docker Compose: docker-compose run positions_feed -url <vehicle-position-url>","title":"Vehicle Position Feed"},{"location":"gtfu/#service-alert-feed","text":"A command line utility that dumps active alerts for an operator to a terminal window. To run: scripts/dump-service-alerts.sh <service-alert-url> With Docker and Docker Compose: docker-compose run service_alerts <service-alert-url>","title":"Service Alert Feed"},{"location":"gtfu/#service-alert-ui","text":"A desktop app to let a user post GTFS service alerts. To run: scripts/alert-ui.sh -url <path-to-config-file> Below is an example for a config file. Make sure to substitute the appropriate values for your scenario. { \"private_key_file\": \"/Users/foo/id_rsa\", \"static_gtfs_url\": \"http://operator.com/gtfs.zip\", \"post_url\": \"https://operator.com/post-service-alert\" }","title":"Service Alert UI"},{"location":"gtfu/#realtime-operator-visualization","text":"Provides ongoing realtime visualization for a GTFS-rt compliant operator. Visuals are created by combining the static GTFS data with the realtime Vehicle Position Feed. Coordinates are auto-scaled to display all routes for an operator. Routes are drawn in the colors specified in the GTFS file. Stops are drawn in gray, vehicles are shown in magenta. Clicking on a stop shows the stop name, clicking on a vehicle shows the schedule adherence status (early, on time, late). In the upper left corner, we show the operator name, and vehicle, stop and trip count. The first time data for an operator is shown, the system downloads and caches the static GTFS zip file. On subsequent runs, the modification time of the zip URL is checked against the cache timestamp. If the URL content is newer, we update the cache. The vehicle position feed is sampled every few seconds, and any updates are reflected on the screen. Pressing n or p switches to the next or previous operator feed, respectively. We show a loading overlay while switching operators. The overlay has two progress bars, data download up top and data parsing at the bottom. To run: scripts/realtime-visualization.sh <path-to-config-file> Below is an example for a config file. Make sure to substitute the appropriate values for your scenario. [ { \"agency_id\": \"agency-1\", \"static_gtfs_url\": \"http://agency-1.com/gtfs.zip\", \"vehicle_position_url\": \"http://agency-1.com/vehicle-positions.pb\" }, { \"agency_id\": \"agency-2\", \"static_gtfs_url\": \"http://agency-2.com/gtfs.zip\", \"vehicle_position_url\": \"http://agency-2.com/vehicle-positions.pb\" }, ]","title":"Realtime Operator Visualization"},{"location":"gtfu/#trip-list-utility","text":"A command line utility for generating a list of friendly trip names from a static GTFS feed. This is part of the onboarding process for new operators, see here for more details. To run: scripts/dump-service-alerts.sh <tmp-dir> <agency-id> <static-gtfs-url> With Docker and Docker Compose: docker-compose run trip_list_generator <tmp-dir> <agency-id> <static-gtfs-url> Use something like /tmp/gtfu-cache as tmp-dir .","title":"Trip List Utility"},{"location":"gtfu/#gtfs-validator","text":"This library utilizes MobilityData's gtfs-validator tool . It runs as a part of the TripListGenerator tool, and you can also run it with the command: java -cp build/libs/gtfu.jar gtfu.tools.GTFSValidator <agency-static-gtfs-url>","title":"GTFS Validator"},{"location":"gtfu/#to-build","text":"gradle distZip","title":"To Build"},{"location":"hardware/","text":"Babyshark Open-source Hardware Documentation: Bill of Materials Below are the materials used by the Cal-ITP team to construct the original Baby Shark. These materials are not requirements, rather they are suggestions. So long as the end product meets the product goals and is completed at a low cost, modifications are allowed and encouraged. Item # Component Units Unit cost Notes 1 Raspberry Pi 4 GB 1 $59.54 Open source hardware 2 SIM7600A-H 4G HAT 1 $78.58 Make sure that you are choosing the correct region for this product 3 Cooling Fan 1 $3.60 4 470 Ohm resistor 1 $0.84 5 Ribbon cables 8inch, 4-wire strand 1 $0.86 6 Accelerometer 1 $7.35 7 SIM Extender 1 $19.60 8 15mm M2 nylon spacer 4 $0.16 9 25mm flathead M2 screw 4 $0.14 10 5mm flathead M2 screw 2 $0.25 11 4mm flathead M2 screws 4 $0.25 12 6mm flathead M2 screws 4 $0.13 13 1mm heat shrink tubes 0.5 $0.85 Units is in feet 14 USB-C extender 1 $4.54 15 M2 nylon washer 20 $0.04 16 SD card 1 $8.62 17 Raspberry pi power connector 1 $10.60 Open source hardware 18 uxcell USB 2.0 Type A Male Socket Connector Jack Port 30 $0.29 19 WEIJ 20 Pcs Micro USB Male Type B 5-Pin Jack Port Solder Connector 20 $0.35 20 LED 1 $0.46 Total: $197.54 Pre-Fabrication: LED: Components include (numbers correspond to bill of materials above): 01 - Raspberry Pi 4 GB 04 - 470 Ohm resistor 05 - Ribbon cables 8inch, 4-wire strand 13 - 1mm heat shrink tubes To start assembling the LED, go through the following steps: Peel off 2 wires from the bunch of ribbon cables. Cut to 11 cm in length measuring from the female side. Shorten LED leads to 3 and 6 mm respectively, making sure to leave a length difference. Shorten resistor leads to 3 mm on each side Cut 2.5 mm heat shrink tube to size, a couple of mm longer than resistor span Solder resistor to shorter LED lead using flux Strip one wire in strand Hold LED and resistor next to strand so that tip of stripped wire is level with bottom of LED Cut other wire so that its end is level with bottom end of resistor body Strip said wire Flux and tin wire tips Push 2.5 mm heat shrink tube over shorter wire, 1 mm heat shrink tube over longer wire Solder short wire end to open resistor lead using flux Solder longer wire to open LED lead using flux Push heat shrink tubes up against LED Use heat gun to shrink tubes Once you are done with these steps you should have something that looks like this: Accelerometer: Components include (numbers correspond to bill of materials above): 01 - Raspberry Pi 4 GB 05 - Ribbon cables 8inch, 4-wire strand 06 - Accelerometer 13 - 1mm heat shrink tubes Notes: Wire length = 9 cm Be sure to use 1 mm heat shrink tube Accelerometer ground (gnd) to pi gnd (6) Accelerometer vcc to pi 3v3 (1) Accelerometer sda to pi sda (3) Accelerometer scl to pi scl (5) (numbers in parentheses correspond to pins on the Raspberry Pi\u2019s general IO connector.) Divide short ribbon into strands of 4 wires each Remove male ends Strip insulation from individual wires Apply flux and tin to stripped wire tips Push heat shrink tubes over wire tips Hold PCB components down and screw holes facing away Stick tinned ends through two leftmost and two rightmost solder holes on the accelerometer board when it is oriented so that the components face the user and the holes face down. Clamp board into third hand or similar without tinned ends slipping out of holes Prop up wire strand from below to keep ends inserted Flux holes with ends Solder tinned tips to holes Using flush cutters, snip off solder and wire tips protruding past bottom of PCB Re-melt solder in holes for smoother surface Push up heat shrink tubes against PCB and shrink with heat gun USB Connector between Pi and Waveshare: Components: 01 - Raspberry Pi 4 GB 02 - SIM7600A-H 4G HAT 05 - Ribbon cables 8inch, 4-wire strand 13 - 1mm heat shrink tubes (\"units\" is in feet) Cut ribbon to 13.5 cm length, removing both male and female ends Divide into strands of 4 wires each Peel individual wires apart at each end to about 3 cm Strip insulation from individual wires Flux and tin wire tips Push about 1.25 cm of heat shrink tube over each wire, continuing up as much as the wire allows If necessary, bend USB A pins to be at right angle to connector and parallel to each other Flux and tin pins Starting with a center pin, solder a tinned wire end to each pin Push up heat shrink tubes against pins and apply heat gun to shrink Flux and tin USB micro pins (only one of the pins on the two-pin side needs connecting, refer to diagram above) Attach wires to pins according to diagram above Push up heat shrink tubes against pins and apply heat gun to shrink Check if the cable is working by connecting the Raspberry Pi and the waveshare and running 'microcom -D /dev/ttyUSB2'. At prompt, enter 'at'. If the cable is correctly connected, waveshare will reply with 'OK'. Assembly - Stage I: Remove waveshare from packaging, take styrofoam protector off GPIO pins and turn board upside down. This is what you should see: Slide sim connector to the right to open: Thread male end of sim extender through bracket as shown: Pull male end through further, then feed into bracket as shown: Close bracket on connector, making sure that sim male end fits into connector cutouts, then slide top bracket to the left to secure Remove pi from packaging, turn upside down and insert micro SD card with OS image into card slot as shown: Connect pi and Waveshare GPIO pins, being careful to properly align both banks. Don't insert pins all the way; leave 1mm of space. See step 8. Further connect boards using 4 M2 25 mm screws, 8 M2 nylon washers and 4 hex M2 nylon spacers, as shown. Then push GPIO pins in all the way Connect LTE cable to board MAIN and GPS cable to board GNSS as shown. There needs to be a clearly audible snap from each connector Connect Pi and waveshare USB ports through cable as shown. Note that cable may look different from image Connect LTE and GPS antennas, display, keyboard, mouse and power Boot up pi. There may be a message about resizing the root file system and then the screen may go and stay blank. If that happens, wait a few minutes, then unplug and restart the Pi. Go through the operating system (OS) setup process, make sure to configure a wireless network to join. Setup process may include substantial OS updates. After pi reboots, log in with the password you set, open a terminal window and type tf. After you hit enter, you should see messages about sending GPS updates to the server if everything is set up right. NOTE: software set up instructions coming soon. Final Assembly - Stage II: Thread two M2 nuts each onto 2 M2 x 10mm screws. Attach fan to case using top two fan housing screw holes Put an M2 nylon washer each onto 2 M2 x 5mm screws. Attach SIM extender to case using top two extender screw holes Put an M2 nylon washer each onto 2 M2 x 6mm screws. Attach accelerometer to case using top two accelerometer screw holes Attach USB-C extender to case using a glob of Kwik Weld or similar. Roughen plastic housing of extender with a few diagonal serrated knife cuts to provide better grip for the glue.","title":"Hardware"},{"location":"hardware/#babyshark-open-source-hardware-documentation","text":"","title":"Babyshark Open-source Hardware Documentation:"},{"location":"hardware/#bill-of-materials","text":"Below are the materials used by the Cal-ITP team to construct the original Baby Shark. These materials are not requirements, rather they are suggestions. So long as the end product meets the product goals and is completed at a low cost, modifications are allowed and encouraged. Item # Component Units Unit cost Notes 1 Raspberry Pi 4 GB 1 $59.54 Open source hardware 2 SIM7600A-H 4G HAT 1 $78.58 Make sure that you are choosing the correct region for this product 3 Cooling Fan 1 $3.60 4 470 Ohm resistor 1 $0.84 5 Ribbon cables 8inch, 4-wire strand 1 $0.86 6 Accelerometer 1 $7.35 7 SIM Extender 1 $19.60 8 15mm M2 nylon spacer 4 $0.16 9 25mm flathead M2 screw 4 $0.14 10 5mm flathead M2 screw 2 $0.25 11 4mm flathead M2 screws 4 $0.25 12 6mm flathead M2 screws 4 $0.13 13 1mm heat shrink tubes 0.5 $0.85 Units is in feet 14 USB-C extender 1 $4.54 15 M2 nylon washer 20 $0.04 16 SD card 1 $8.62 17 Raspberry pi power connector 1 $10.60 Open source hardware 18 uxcell USB 2.0 Type A Male Socket Connector Jack Port 30 $0.29 19 WEIJ 20 Pcs Micro USB Male Type B 5-Pin Jack Port Solder Connector 20 $0.35 20 LED 1 $0.46 Total: $197.54","title":"Bill of Materials"},{"location":"hardware/#pre-fabrication","text":"","title":"Pre-Fabrication:"},{"location":"hardware/#led","text":"Components include (numbers correspond to bill of materials above): 01 - Raspberry Pi 4 GB 04 - 470 Ohm resistor 05 - Ribbon cables 8inch, 4-wire strand 13 - 1mm heat shrink tubes To start assembling the LED, go through the following steps: Peel off 2 wires from the bunch of ribbon cables. Cut to 11 cm in length measuring from the female side. Shorten LED leads to 3 and 6 mm respectively, making sure to leave a length difference. Shorten resistor leads to 3 mm on each side Cut 2.5 mm heat shrink tube to size, a couple of mm longer than resistor span Solder resistor to shorter LED lead using flux Strip one wire in strand Hold LED and resistor next to strand so that tip of stripped wire is level with bottom of LED Cut other wire so that its end is level with bottom end of resistor body Strip said wire Flux and tin wire tips Push 2.5 mm heat shrink tube over shorter wire, 1 mm heat shrink tube over longer wire Solder short wire end to open resistor lead using flux Solder longer wire to open LED lead using flux Push heat shrink tubes up against LED Use heat gun to shrink tubes Once you are done with these steps you should have something that looks like this:","title":"LED:"},{"location":"hardware/#accelerometer","text":"Components include (numbers correspond to bill of materials above): 01 - Raspberry Pi 4 GB 05 - Ribbon cables 8inch, 4-wire strand 06 - Accelerometer 13 - 1mm heat shrink tubes Notes: Wire length = 9 cm Be sure to use 1 mm heat shrink tube Accelerometer ground (gnd) to pi gnd (6) Accelerometer vcc to pi 3v3 (1) Accelerometer sda to pi sda (3) Accelerometer scl to pi scl (5) (numbers in parentheses correspond to pins on the Raspberry Pi\u2019s general IO connector.) Divide short ribbon into strands of 4 wires each Remove male ends Strip insulation from individual wires Apply flux and tin to stripped wire tips Push heat shrink tubes over wire tips Hold PCB components down and screw holes facing away Stick tinned ends through two leftmost and two rightmost solder holes on the accelerometer board when it is oriented so that the components face the user and the holes face down. Clamp board into third hand or similar without tinned ends slipping out of holes Prop up wire strand from below to keep ends inserted Flux holes with ends Solder tinned tips to holes Using flush cutters, snip off solder and wire tips protruding past bottom of PCB Re-melt solder in holes for smoother surface Push up heat shrink tubes against PCB and shrink with heat gun","title":"Accelerometer:"},{"location":"hardware/#usb-connector-between-pi-and-waveshare","text":"Components: 01 - Raspberry Pi 4 GB 02 - SIM7600A-H 4G HAT 05 - Ribbon cables 8inch, 4-wire strand 13 - 1mm heat shrink tubes (\"units\" is in feet) Cut ribbon to 13.5 cm length, removing both male and female ends Divide into strands of 4 wires each Peel individual wires apart at each end to about 3 cm Strip insulation from individual wires Flux and tin wire tips Push about 1.25 cm of heat shrink tube over each wire, continuing up as much as the wire allows If necessary, bend USB A pins to be at right angle to connector and parallel to each other Flux and tin pins Starting with a center pin, solder a tinned wire end to each pin Push up heat shrink tubes against pins and apply heat gun to shrink Flux and tin USB micro pins (only one of the pins on the two-pin side needs connecting, refer to diagram above) Attach wires to pins according to diagram above Push up heat shrink tubes against pins and apply heat gun to shrink Check if the cable is working by connecting the Raspberry Pi and the waveshare and running 'microcom -D /dev/ttyUSB2'. At prompt, enter 'at'. If the cable is correctly connected, waveshare will reply with 'OK'.","title":"USB Connector between Pi and Waveshare:"},{"location":"hardware/#assembly-stage-i","text":"Remove waveshare from packaging, take styrofoam protector off GPIO pins and turn board upside down. This is what you should see: Slide sim connector to the right to open: Thread male end of sim extender through bracket as shown: Pull male end through further, then feed into bracket as shown: Close bracket on connector, making sure that sim male end fits into connector cutouts, then slide top bracket to the left to secure Remove pi from packaging, turn upside down and insert micro SD card with OS image into card slot as shown: Connect pi and Waveshare GPIO pins, being careful to properly align both banks. Don't insert pins all the way; leave 1mm of space. See step 8. Further connect boards using 4 M2 25 mm screws, 8 M2 nylon washers and 4 hex M2 nylon spacers, as shown. Then push GPIO pins in all the way Connect LTE cable to board MAIN and GPS cable to board GNSS as shown. There needs to be a clearly audible snap from each connector Connect Pi and waveshare USB ports through cable as shown. Note that cable may look different from image Connect LTE and GPS antennas, display, keyboard, mouse and power Boot up pi. There may be a message about resizing the root file system and then the screen may go and stay blank. If that happens, wait a few minutes, then unplug and restart the Pi. Go through the operating system (OS) setup process, make sure to configure a wireless network to join. Setup process may include substantial OS updates. After pi reboots, log in with the password you set, open a terminal window and type tf. After you hit enter, you should see messages about sending GPS updates to the server if everything is set up right. NOTE: software set up instructions coming soon.","title":"Assembly - Stage I:"},{"location":"hardware/#final-assembly-stage-ii","text":"Thread two M2 nuts each onto 2 M2 x 10mm screws. Attach fan to case using top two fan housing screw holes Put an M2 nylon washer each onto 2 M2 x 5mm screws. Attach SIM extender to case using top two extender screw holes Put an M2 nylon washer each onto 2 M2 x 6mm screws. Attach accelerometer to case using top two accelerometer screw holes Attach USB-C extender to case using a glob of Kwik Weld or similar. Roughen plastic housing of extender with a few diagonal serrated knife cuts to provide better grip for the glue.","title":"Final Assembly - Stage II:"},{"location":"server/","text":"GTFS-RT Server Description This repository contains an early access implementation for a GTFS-RT server and an AVL web app that runs on both android and iOS. The server is implemented in python as a Google App Engine Flask application, the web app is available at https://lat-long-prototype.wl.r.appspot.com. For steps required to onboard a new agency, please see the Onboarding Runbook . To start running the client, press the Start button, then select Route and Bus No from the respective dropdowns. Press Okay to start sending location updates. Upon trip completion, press the Stop button. Deployment Issue gcloud app deploy from the app-engine folder of this repository. Generate Weekly Reports Make sure that you have docker in your path, then run dockerized-report.sh <agency-id> . agency-id needs to be the ID for an onboarded agency.","title":"Server"},{"location":"server/#gtfs-rt-server","text":"","title":"GTFS-RT Server"},{"location":"server/#description","text":"This repository contains an early access implementation for a GTFS-RT server and an AVL web app that runs on both android and iOS. The server is implemented in python as a Google App Engine Flask application, the web app is available at https://lat-long-prototype.wl.r.appspot.com. For steps required to onboard a new agency, please see the Onboarding Runbook . To start running the client, press the Start button, then select Route and Bus No from the respective dropdowns. Press Okay to start sending location updates. Upon trip completion, press the Stop button.","title":"Description"},{"location":"server/#deployment","text":"Issue gcloud app deploy from the app-engine folder of this repository.","title":"Deployment"},{"location":"server/#generate-weekly-reports","text":"Make sure that you have docker in your path, then run dockerized-report.sh <agency-id> . agency-id needs to be the ID for an onboarded agency.","title":"Generate Weekly Reports"},{"location":"server/onboarding-runbook/","text":"Agency Onboarding Runbook Onboarder prerequisites Onboarder refers to the person performing the agency onboarding. Oboarder requires: - Editor access to google cloud project - the following command line tools: - git - gcloud - gsutil - clone two git repos: graas-staging & graas-agency-keys. TODO : dockerize onboarding Agency prerequisites agency must have a publicly available static GTFS URL, including headsigns for each trip. You can verify that a given URL is valid by downloading the contents of the URL with the command curl -o gtfs.zip <agency-gtfs-url> unpacking the zip with unzip gtfs.zip this should yield files like agency.txt, trips.txt, routes.txt, etc. agency needs to provide a list of vehicle IDs to uniquely identify each service vehicle. For smaller agencies who don't have existing vehicle IDs, this could be the last three digits of the VIN agency needs to provide a list of friendly trip names for the drivers to choose from when starting the web app. The default way of naming trips is to combine the head sign for each trip with the departure time at the first stop, e.g. Venice Beach @ 3:05 pm . If the agency doesn't find this scheme acceptable, then they need to provide a list of trip names. There is a tool available here that automatically generates a list of trip names in the default scheme. Create service data for agency Go to agencies.yml , a Cal-ITP source-of-truth, in order to determine the agency-id for this agency. From graas-staging/server/agency-config/gtfs , run the command ./setup-agency-templates.sh <id> . This will create a directory for the agency at graas-staging/server/agency-config/gtfs/gtfs-aux/<agency-id> , containing 3 files: filter-params.json route-names.json vehicle-ids.json Add the vehicle IDs provided by the agency to vehicle-ids.json . Assuming the agency has IDs 001 , 002 and 003 the the file should look like this: [ \"001\", \"002\", \"003\" ] Within the gtfu directory, run the command java -cp build/libs/gtfu.jar gtfu.tools.TripListGenerator -f -i <agency-id> . Note that you'll need to add the -h, -r, or -R, to go into the \"route name\". Once the output is satisfactory, run the same command with the \"-oa\" flag to send the output directly to the agency's route-names.json file, which will look like this: [ {\"route_name\": \"Valley West (Northbound) @ 1:59 pm\", \"trip_id\": \"t_1194609_b_26559_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.780441, \"long\": -124.188820}}, {\"route_name\": \"Valley West (Northbound) @ 4:12 pm\", \"trip_id\": \"t_1194610_b_26559_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.780441, \"long\": -124.188820}}, {\"route_name\": \"Valley West (Northbound) @ 5:07 pm\", \"trip_id\": \"t_1194611_b_26559_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.780441, \"long\": -124.188820}}, {\"route_name\": \"Willow Creek (Eastbound) @ 8:25 am\", \"trip_id\": \"t_1522946_b_30738_tn_0\", \"calendar\": [1, 1, 1, 1, 1, 0, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}}, {\"route_name\": \"Willow Creek (Eastbound) @ 8:25 am\", \"trip_id\": \"t_1522952_b_30738_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}}, {\"route_name\": \"Willow Creek (Eastbound) @ 10:40 am\", \"trip_id\": \"t_1522950_b_30738_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}}, {\"route_name\": \"Willow Creek (Eastbound) @ 3:45 pm\", \"trip_id\": \"t_1522945_b_30738_tn_0\", \"calendar\": [1, 1, 1, 1, 1, 0, 0], \"departure_pos\": {\"lat\": 40.874722, \"long\": -124.084763}}, {\"route_name\": \"Willow Creek (Eastbound) @ 5:40 pm\", \"trip_id\": \"t_1522951_b_30738_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}} ] Confirm that none of the calendar arrays are null. If they are, those routes will be hidden by default, and you should ask the agency to update the GTFS feed From graas-staging/server/agency-config/gtfs , run ./copy-to-bucket.sh <agency-id> to copy the new data files to the project storage bucket (this script will throw an error and cancel upload if json is misformatted). Check the storage bucket source of truth to confirm that your updates went through. You can run this command whenever you update either file. Create keys for agency From graas-staging/server/app-engine , run python keygen.py -a <agency-id> . This uploads the public key to Google Cloud and generates a folder called <agency-id> with two files inside it: - id_ecdsa : private key. This is PRIVILEGED INFORMATION and needs to be kept confidential. - id_ecdsa.pub : public key Move this new agency key folder to the graas-agency-keys repo (or elsewhere if you prefer). This is privleged information and shouldn't live on the open-source repo. Create a unique agency QR code, which encodes the private key, to be read by the GRaaS app. Generate the code by going to the graas-staging/server/qr-gen directory and running ./run.sh ../../../graas-agency-keys/<agency-id>/id_ecdsa \"<nickname for agency>\" . This will save a file called \"qr.png\" to the qr-gen folder - you'll want to paste this into the onboarding docs provided to the agency. You can visit this page to confirm the key was added to Google datastore Device Setup On agency device, visit the web app and create \"home screen shortcut\" to this URL (e.g. for iOS see here ) Open web app via home screen. Grant camera access to the app and scan the agency QR code. This will save the private key to the device. Press Start , then select an arbitrary route and vehicle and press Okay . Press Allow for the Location Services dialog that appears, then press the Stop button in the app. Device Maintenance All devices used for GPS data collection need to be rebooted once a week. Testing locally Run the command python main.py to run the app on your local machine. You can access the app via localhost, and possibly use ngrok to test it from your mobile device. Deploying changes Test changes and create a PR, solicit feedback from team members When you have a +1 from teammates etc, deploy changes by running gcloud app deploy TODO : confirm whether to run this from venv or not General troubleshooting To check whether an agency is publishing data, run the command gcloud app logs tail If the agency isn't seeing seeing any route results from the dropdown, confirm that they are starting the app while physically near the first stop (1/4 mile) and within 30 minutes of the start time. If it still isnt working, edit the parameters in route-names.json (note that if they don't have parameters listed, the app defaults to some - you can see in app-engine/templates/staging.html line 1094). If you need to get the logs for a given day, run the following command from venv within the app-engine directory: python get-pos.py -a <agency-id> -d MM/DD/YY -t > <agency-name>-MM-DD-YY.log","title":"Runbook"},{"location":"server/onboarding-runbook/#agency-onboarding-runbook","text":"","title":"Agency Onboarding Runbook"},{"location":"server/onboarding-runbook/#onboarder-prerequisites","text":"Onboarder refers to the person performing the agency onboarding. Oboarder requires: - Editor access to google cloud project - the following command line tools: - git - gcloud - gsutil - clone two git repos: graas-staging & graas-agency-keys. TODO : dockerize onboarding","title":"Onboarder prerequisites"},{"location":"server/onboarding-runbook/#agency-prerequisites","text":"agency must have a publicly available static GTFS URL, including headsigns for each trip. You can verify that a given URL is valid by downloading the contents of the URL with the command curl -o gtfs.zip <agency-gtfs-url> unpacking the zip with unzip gtfs.zip this should yield files like agency.txt, trips.txt, routes.txt, etc. agency needs to provide a list of vehicle IDs to uniquely identify each service vehicle. For smaller agencies who don't have existing vehicle IDs, this could be the last three digits of the VIN agency needs to provide a list of friendly trip names for the drivers to choose from when starting the web app. The default way of naming trips is to combine the head sign for each trip with the departure time at the first stop, e.g. Venice Beach @ 3:05 pm . If the agency doesn't find this scheme acceptable, then they need to provide a list of trip names. There is a tool available here that automatically generates a list of trip names in the default scheme.","title":"Agency prerequisites"},{"location":"server/onboarding-runbook/#create-service-data-for-agency","text":"Go to agencies.yml , a Cal-ITP source-of-truth, in order to determine the agency-id for this agency. From graas-staging/server/agency-config/gtfs , run the command ./setup-agency-templates.sh <id> . This will create a directory for the agency at graas-staging/server/agency-config/gtfs/gtfs-aux/<agency-id> , containing 3 files: filter-params.json route-names.json vehicle-ids.json Add the vehicle IDs provided by the agency to vehicle-ids.json . Assuming the agency has IDs 001 , 002 and 003 the the file should look like this: [ \"001\", \"002\", \"003\" ] Within the gtfu directory, run the command java -cp build/libs/gtfu.jar gtfu.tools.TripListGenerator -f -i <agency-id> . Note that you'll need to add the -h, -r, or -R, to go into the \"route name\". Once the output is satisfactory, run the same command with the \"-oa\" flag to send the output directly to the agency's route-names.json file, which will look like this: [ {\"route_name\": \"Valley West (Northbound) @ 1:59 pm\", \"trip_id\": \"t_1194609_b_26559_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.780441, \"long\": -124.188820}}, {\"route_name\": \"Valley West (Northbound) @ 4:12 pm\", \"trip_id\": \"t_1194610_b_26559_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.780441, \"long\": -124.188820}}, {\"route_name\": \"Valley West (Northbound) @ 5:07 pm\", \"trip_id\": \"t_1194611_b_26559_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.780441, \"long\": -124.188820}}, {\"route_name\": \"Willow Creek (Eastbound) @ 8:25 am\", \"trip_id\": \"t_1522946_b_30738_tn_0\", \"calendar\": [1, 1, 1, 1, 1, 0, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}}, {\"route_name\": \"Willow Creek (Eastbound) @ 8:25 am\", \"trip_id\": \"t_1522952_b_30738_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}}, {\"route_name\": \"Willow Creek (Eastbound) @ 10:40 am\", \"trip_id\": \"t_1522950_b_30738_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}}, {\"route_name\": \"Willow Creek (Eastbound) @ 3:45 pm\", \"trip_id\": \"t_1522945_b_30738_tn_0\", \"calendar\": [1, 1, 1, 1, 1, 0, 0], \"departure_pos\": {\"lat\": 40.874722, \"long\": -124.084763}}, {\"route_name\": \"Willow Creek (Eastbound) @ 5:40 pm\", \"trip_id\": \"t_1522951_b_30738_tn_0\", \"calendar\": [0, 0, 0, 0, 0, 1, 0], \"departure_pos\": {\"lat\": 40.868565, \"long\": -124.084099}} ] Confirm that none of the calendar arrays are null. If they are, those routes will be hidden by default, and you should ask the agency to update the GTFS feed From graas-staging/server/agency-config/gtfs , run ./copy-to-bucket.sh <agency-id> to copy the new data files to the project storage bucket (this script will throw an error and cancel upload if json is misformatted). Check the storage bucket source of truth to confirm that your updates went through. You can run this command whenever you update either file.","title":"Create service data for agency"},{"location":"server/onboarding-runbook/#create-keys-for-agency","text":"From graas-staging/server/app-engine , run python keygen.py -a <agency-id> . This uploads the public key to Google Cloud and generates a folder called <agency-id> with two files inside it: - id_ecdsa : private key. This is PRIVILEGED INFORMATION and needs to be kept confidential. - id_ecdsa.pub : public key Move this new agency key folder to the graas-agency-keys repo (or elsewhere if you prefer). This is privleged information and shouldn't live on the open-source repo. Create a unique agency QR code, which encodes the private key, to be read by the GRaaS app. Generate the code by going to the graas-staging/server/qr-gen directory and running ./run.sh ../../../graas-agency-keys/<agency-id>/id_ecdsa \"<nickname for agency>\" . This will save a file called \"qr.png\" to the qr-gen folder - you'll want to paste this into the onboarding docs provided to the agency. You can visit this page to confirm the key was added to Google datastore","title":"Create keys for agency"},{"location":"server/onboarding-runbook/#device-setup","text":"On agency device, visit the web app and create \"home screen shortcut\" to this URL (e.g. for iOS see here ) Open web app via home screen. Grant camera access to the app and scan the agency QR code. This will save the private key to the device. Press Start , then select an arbitrary route and vehicle and press Okay . Press Allow for the Location Services dialog that appears, then press the Stop button in the app.","title":"Device Setup"},{"location":"server/onboarding-runbook/#device-maintenance","text":"All devices used for GPS data collection need to be rebooted once a week.","title":"Device Maintenance"},{"location":"server/onboarding-runbook/#testing-locally","text":"Run the command python main.py to run the app on your local machine. You can access the app via localhost, and possibly use ngrok to test it from your mobile device.","title":"Testing locally"},{"location":"server/onboarding-runbook/#deploying-changes","text":"Test changes and create a PR, solicit feedback from team members When you have a +1 from teammates etc, deploy changes by running gcloud app deploy TODO : confirm whether to run this from venv or not","title":"Deploying changes"},{"location":"server/onboarding-runbook/#general-troubleshooting","text":"To check whether an agency is publishing data, run the command gcloud app logs tail If the agency isn't seeing seeing any route results from the dropdown, confirm that they are starting the app while physically near the first stop (1/4 mile) and within 30 minutes of the start time. If it still isnt working, edit the parameters in route-names.json (note that if they don't have parameters listed, the app defaults to some - you can see in app-engine/templates/staging.html line 1094). If you need to get the logs for a given day, run the following command from venv within the app-engine directory: python get-pos.py -a <agency-id> -d MM/DD/YY -t > <agency-name>-MM-DD-YY.log","title":"General troubleshooting"}]}